package tkmp.schedule;


import javax.swing.*;
import javax.swing.table.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.GregorianCalendar;
import java.util.StringTokenizer;
import java.util.stream.Stream;

public class Main {

    static JLabel lblMonth, lblYear;
    static JButton btnPrev, btnNext;
    static JTable tblCalendar;
    static JComboBox cmbYear;
    static Container container;
    static DefaultTableModel mtblCalendar;
    static JScrollPane stblCalendar;
    static JPanel pnlCalendar;
    static int realYear, realMonth, realDay, currentYear, currentMonth;

    public static void main(String[] args) {
        System.setProperty("file.encoding", "UTF-8");
        try {
            for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (Exception e) {
            // If Nimbus is not available, you can set the GUI to another look and feel.
        }


        TableDate isStart = new TableDate();
        isStart.signInFrame();

        isStart.mainFrame();

    }


    static class TableDate extends JFrame implements ActionListener {

        private static final String ENCODING_UTF8 = "UTF-8";

        final static String FILE_OF_TABLE_BS = "DoneSchedule.txt",
                FILE_CHECK_SAVE_DATE = "Check.txt",
                FILE_OF_NAMES = "NamesList.txt",
                FILE_OF_GROUPS = "GroupsList.txt",
                FILE_OF_SUBJECTS = "SubjectsList.txt",
                FILE_OF_REPOSITORY = "Repository.txt",
                FILE_OF_TABLE_HOURS = "TableOfHours.txt",
                FILE_OF_USER_DATE = "UserOfDate.txt";

        static JTable TableSchedule,
                tableHours;
        static JPanel lowPanel,
                commonPanel;
        JFrame frameOfTable;

        static JFrame mainFrame;
        static JFrame authorization;
        static JTextArea generalLst;
        static JTextArea notes;

        static JButton openFormSubjects,
                openFormNames,
                openFormGroups,
                viewSavedSchedule,
                addDateToFile,
                createSchedule,
                beginBuild,
                deleteDateFromFiles,
                sortOnClick,
                signIn,
                signUpAccount,
                signUp,
                saveDataNotes,
                printSavedTable,
                openCellOfTable,
                saveTableOfHours,
                backUpOfData,
                recoveryOfDate;

        static JLabel infoAboutOperation,
                infoEnter,
                infoRepeat,
                rule,
                imageBack,
                icon,
                infoSI_SU,
                infoAboutEvent;

        JScrollPane pane;
        JTextField isText,
                textForGroups,
                textForNames,
                textForSubjects;
        static JTextField rules;

        static String DataForTable = "",
                stringWrite = "",
                stringWriteSort = "",
                dataNotes = "",
                checkSignIn = "",
                condition,
                dateFromFile = "";

        String[] listForNames;
        String[] listForGroups;
        String[] listForSubjects;
        String line = "";

        int linesCount = 0,
                linesCountForNew = 0,
                lineCountForNames = 0,
                linesCountsForGroups = 0,
                linesCountsForSubjects = 0;

        static JComboBox<String> boxNames,
                boxGroups,
                boxSubjects,
                sortBoxNames,
                sortBoxGroups;

        final String MASSAGE_ERROR_NOT_FOUND_FILE = "Отсутствует файл",
                NAME_ERROR_SUBJECTS = "Дисциплины",
                NAME_ERROR_GROUPS = "Группы",
                NAME_ERROR_NAMES = "Names",
                NAME_ERROR_NOTES= "Заметки",
                NAME_ERROR_TABLE = "Таблица составления расписания",
                NAME_ERROR_TABLE_OF_SAVE = "Таблица сохранения расписания",
                NAME_ERROR_TABLE_OF_HOURS = "Таблица часов",
                INFO_ABOUT_WORK = "Предварительно необходимо " +
                        "выбрать параметр для сортировки",
                ATTENTION_NOT_SELECTED_TABLE = "Предварительно необходимо " +
                        "открыть таличную часть для " +
                        "дальнейшей печати!",
                INFO_RECOVERY = "<html> Вы действительно хотите восстановить в исходное состояние? " +
                        "<br/>" +
                        "Данная процедура создаст новые базы данных для дальнейшей работы " +
                        "без сохранения данных предыдущих баз (если они имеются)" +
                        "<br/>" +
                        "Это операция необходима при возникновении проблем с" +
                        " отсутствием чтения данных </html> ",

        INFO_ABOUT_SU = "<html> Для продолжения создайте <br/> " +
                "новую учетную запись! </html>",
                INFO_ABOUT_SI = "Войдите как администратор или продолжите";

        static JPasswordField passwordUser,
                repeatPU,
                passwordUserCheck;



        final Color COLOR_BORDER_WRONG = new Color(214, 63, 17);
        final Color COLOR_BORDER_SUCCESS = new Color(63, 132, 17);

        DefaultTableModel newModelForStorage;

        static DefaultTableModel model;
        static DefaultTableModel th_call;

        DefaultCellEditor Storage;

        Object saveTable = "";

        static JProgressBar progressBar;

        public void showPanelCreateAccount() {
            imageBack.setIcon(new ImageIcon("src/bg_dark.jpg"));

            infoAboutOperation.setVisible(true);
            signUpAccount.setVisible(true);
            passwordUser.setVisible(true);
            repeatPU.setVisible(true);
            infoEnter.setVisible(true);
            infoRepeat.setVisible(true);
            rule.setVisible(true);
            rules.setVisible(true);
        }

        public void blockAll() {
            infoAboutOperation.setVisible(false);
            signUpAccount.setVisible(false);
            passwordUser.setVisible(false);
            repeatPU.setVisible(false);
            infoEnter.setVisible(false);
            infoRepeat.setVisible(false);
            rule.setVisible(false);
            rules.setVisible(false);
        }

        public void signInFrame() {

            passwordUserCheck = new JPasswordField();

            passwordUserCheck.setBorder(null);
            signIn = new JButton("Войти");
            signUp = new JButton("Создать");

            try (FileReader dateFromUoD = new FileReader(FILE_OF_USER_DATE)) {
                BufferedReader begin = new BufferedReader(dateFromUoD);
                checkSignIn = begin.readLine();

                if (checkSignIn == null) {
                    signIn.setEnabled(false);
                }

            } catch (Exception ex) {
                JOptionPane.showMessageDialog(null, "Файл не найден");
            }


            if (checkSignIn == null) {
                condition = "isEmpty";
            }

            if (checkSignIn != null) {
                condition = "notIsEmpty";
            }

            System.out.println("Current condition [" + condition + "]");

            imageBack = new JLabel(new ImageIcon("src/bg.jpg")); // or IMG.

            infoAboutOperation = new JLabel("<html> Создайте пароль для " +
                    "дальнейшей аутентификации </html> ");

            infoEnter = new JLabel("Введите пароль");
            infoRepeat = new JLabel("Повторите пароль");
            rule = new JLabel("Роль:");

            infoAboutOperation.setFont(new Font("Verdana", Font.BOLD, 14));
            infoRepeat.setFont(new Font("Verdana", Font.BOLD, 13));
            infoEnter.setFont(new Font("Verdana", Font.BOLD, 13));
            rule.setFont(new Font("Verdana", Font.BOLD, 13));

            infoAboutOperation.setForeground(new Color(255, 255, 255));
            infoRepeat.setForeground(new Color(255, 255, 255));
            infoEnter.setForeground(new Color(255, 255, 255));
            rule.setForeground(new Color(255, 255, 255));

            rules = new JTextField("Администратор");
            rules.setEnabled(false);

            passwordUser = new JPasswordField();
            repeatPU = new JPasswordField();

            signUpAccount = new JButton("Зарегистрироваться");
            signUpAccount.addActionListener(new CheckingDate());

            blockAll();

            icon = new JLabel(new ImageIcon("src/confirm_verify.png"));
            icon.setVisible(false);

            infoSI_SU = new JLabel();
            infoSI_SU.setFont(new Font("Verdana", Font.BOLD, 14));
            infoSI_SU.setForeground(new Color(255, 255, 255));

            if (condition.equals("notIsEmpty")) {
                signUp.setEnabled(false);
            }

            signUp.addActionListener(new CheckingAuth());
            signIn.addActionListener(new ContinueSI());
            authorization = new JFrame("Вход в систему");

            authorization.setIconImage(Toolkit.getDefaultToolkit().getImage("src/iconOfFrame.png"));

            commonPanel = new JPanel();
            commonPanel.setLayout(null);

            if (condition.equals("isEmpty")) {
                infoSI_SU.setText(INFO_ABOUT_SU);

            } else
                infoSI_SU.setText(INFO_ABOUT_SI);

            System.out.println("Current condition [" + condition + "]");

            imageBack.setBounds(0, 0, 1200, 600);
            infoSI_SU.setBounds(60, 50, 400, 35);
            passwordUserCheck.setBounds(60, 100, 230, 25);
            signIn.setBounds(60, 135, 110, 30);
            signUp.setBounds(181, 135, 110, 30);
            icon.setBounds(1045, 30, 50, 50);

            infoAboutOperation.setBounds(620, 50, 500, 25);
            infoEnter.setBounds(622, 85, 150, 25);
            passwordUser.setBounds(620, 115, 225, 25);
            infoRepeat.setBounds(622, 145, 150, 25);
            repeatPU.setBounds(620, 175, 225, 25);
            rule.setBounds(622, 205, 225, 25);
            rules.setBounds(620, 235, 225, 30);
            signUpAccount.setBounds(696, 280, 150, 30);

            commonPanel.add(passwordUser);
            commonPanel.add(repeatPU);
            commonPanel.add(infoEnter);
            commonPanel.add(infoRepeat);
            commonPanel.add(rules);
            commonPanel.add(signUpAccount);
            commonPanel.add(rule);
            commonPanel.add(infoAboutOperation);
            commonPanel.add(passwordUserCheck);
            commonPanel.add(signUp);
            commonPanel.add(signIn);
            commonPanel.add(icon);
            commonPanel.add(infoSI_SU);
            commonPanel.add(imageBack);

            authorization.add(commonPanel);
            authorization.setSize(1200, 600);
            authorization.setResizable(false);
            authorization.setLocationRelativeTo(null);
            authorization.setVisible(true);
        }


        public void mainFrame() {

            container = new Container();
            container.setLayout(null);

            lblMonth = new JLabel ("January");
            lblYear = new JLabel ("Change year:");
            cmbYear = new JComboBox();
            btnPrev = new JButton (new ImageIcon("src/left_way.png"));
            btnNext = new JButton (new ImageIcon("src/right_way.png"));
            mtblCalendar = new DefaultTableModel(){public boolean isCellEditable(int rowIndex, int mColIndex){return false;}};
            tblCalendar = new JTable(mtblCalendar);
            stblCalendar = new JScrollPane(tblCalendar);
            pnlCalendar = new JPanel(null);

            btnPrev.addActionListener(new btnPrev_Action());
            btnNext.addActionListener(new btnNext_Action());
            cmbYear.addActionListener(new cmbYear_Action());


            pnlCalendar.add(lblMonth);
            pnlCalendar.add(lblYear);
            pnlCalendar.add(cmbYear);
            pnlCalendar.add(btnPrev);
            pnlCalendar.add(btnNext);
            pnlCalendar.add(stblCalendar);

            pnlCalendar.setBounds(100, 305, 401, 203);
            lblMonth.setBounds(85, 1, 70, 25);
            cmbYear.setBounds(319, 1, 80, 25);
            btnPrev.setBounds(1, 1, 50, 25);
            btnNext.setBounds(170, 1, 50, 25);
            stblCalendar.setBounds(1, 25, 400, 178);

            btnPrev.setContentAreaFilled(false);
            btnNext.setContentAreaFilled(false);


            GregorianCalendar cal = new GregorianCalendar();
            realDay = cal.get(GregorianCalendar.DAY_OF_MONTH);
            realMonth = cal.get(GregorianCalendar.MONTH);
            realYear = cal.get(GregorianCalendar.YEAR);
            currentMonth = realMonth;
            currentYear = realYear;

            String[] headers = {"Пн.", "Вт.", "Ср.", "Чт.", "Пт.", "Сб.", "Вс"};
            for (int i = 0; i < 7; i++){
                mtblCalendar.addColumn(headers[i]);
            }

            tblCalendar.getParent().setBackground(tblCalendar.getBackground());

            tblCalendar.getTableHeader().setResizingAllowed(false);
            tblCalendar.getTableHeader().setReorderingAllowed(false);


            tblCalendar.setColumnSelectionAllowed(true);
            tblCalendar.setRowSelectionAllowed(true);
            tblCalendar.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);


            tblCalendar.setRowHeight(25);
            mtblCalendar.setColumnCount(7);
            mtblCalendar.setRowCount(6);

            for (int i = realYear - 100; i <= realYear + 100; i++){
                cmbYear.addItem(String.valueOf(i));
            }

            refreshCalendar (realMonth, realYear);

            notes = new JTextArea(5,50);
            try (FileReader fr = new FileReader("DataNotes.txt")) {
                BufferedReader reader = new BufferedReader(fr);
                while (dataNotes != null) {
                    dataNotes = reader.readLine();
                    notes.append(dataNotes);
                }
                reader.close();
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(null, "Данные не определенны "
                        + NAME_ERROR_NOTES);
            }

            infoAboutEvent = new JLabel();
            JLabel infoAboutAll = new JLabel("<html> Выберите параметр для сортировки </html>");
            JLabel infoAboutGroups = new JLabel("<html> по группам: </html> ");
            JLabel infoAboutNames = new JLabel("<html> по преподавателям: </html> ");
            JLabel notesInfo = new JLabel("Заметка: ");
            generalLst = new JTextArea(8, 35);

            recoveryOfDate = new JButton(new ImageIcon("src/recovery.png"));
            backUpOfData = new JButton(new ImageIcon("src/back_up.png"));
            openFormSubjects = new JButton(new ImageIcon("src/add_subjects.png"));
            openFormNames = new JButton(new ImageIcon("src/add_names.png"));
            openFormGroups = new JButton(new ImageIcon("src/add_groups.png"));
            deleteDateFromFiles = new JButton(new ImageIcon("src/delete.png"));
            printSavedTable = new JButton(new ImageIcon("src/print.png"));
            openCellOfTable = new JButton(new ImageIcon("src/cellTable.png"));

            viewSavedSchedule = new JButton("Просмотр расписания");

            openFormSubjects.setContentAreaFilled(false);
            openFormNames.setContentAreaFilled(false);
            openFormGroups.setContentAreaFilled(false);
            deleteDateFromFiles.setContentAreaFilled(false);
            printSavedTable.setContentAreaFilled(false);
            openCellOfTable.setContentAreaFilled(false);
            recoveryOfDate.setContentAreaFilled(false);
            backUpOfData.setContentAreaFilled(false);

            openFormSubjects.addActionListener(new OpenFormSubject());
            openFormNames.addActionListener(new OpenFormNames());
            openFormGroups.addActionListener(new OpenFormGroups());
            deleteDateFromFiles.addActionListener(new DeleteAllDates());
            printSavedTable.addActionListener(new PrintTable());
            viewSavedSchedule.addActionListener(new ViewSaveSchedule());
            openCellOfTable.addActionListener(new CellOfTable());
            recoveryOfDate.addActionListener(new FormOfRecovery());
            backUpOfData.addActionListener(new BackUpOfDate());

            createSchedule = new JButton("Создать расписание");
            createSchedule.addActionListener(new BuildSchedule());

            addDateToFile = new JButton("Добавить");
            addDateToFile.addActionListener(new AddDate());

            sortOnClick = new JButton("Сортировать");
            sortOnClick.addActionListener(new SortDate());

            saveDataNotes = new JButton("Сохранить");
            saveDataNotes.addActionListener(new SaveDataNotes());
            mainFrame = new JFrame("Помощник в составлени расписания");
            mainFrame.setIconImage(Toolkit.getDefaultToolkit().getImage("src/iconOfFrame.png"));
            setLayout(null);

            textForGroups = new JTextField(30);
            textForNames = new JTextField(30);
            textForSubjects = new JTextField(30);

            countLinesLocalForName();
            countLinesLocalForGroups();
            countLinesLocalForObjects();

            boxNames = new JComboBox<>(listForNames);
            boxGroups = new JComboBox<>(listForGroups);
            boxSubjects = new JComboBox<>(listForSubjects);

            sortBoxNames = new JComboBox<>(listForNames);
            sortBoxGroups = new JComboBox<>(listForGroups);

            boxNames.addActionListener(this);
            boxSubjects.addActionListener(this);
            boxGroups.addActionListener(this);

            sortBoxNames.addActionListener(this);
            sortBoxGroups.addActionListener(this);

            openFormSubjects.setBounds(10, 20, 32,32);
            openFormSubjects.setToolTipText("<html> Открыть форму для заполнения " +
                    "<br/> данными о дисциплинах </html>");

            openFormNames.setBounds(10, 80, 32,32);
            openFormNames.setToolTipText("<html> Открыть форму для заполнения " +
                    "<br/> данными о преподавателях </html>");

            openFormGroups.setBounds(10, 140, 32,32);
            openFormGroups.setToolTipText("<html> Открыть форму для заполнения " +
                    "<br/> данными о группах </html>");

            printSavedTable.setBounds(10, 200, 32,32);
            printSavedTable.setToolTipText("<html> Создать печатную форму </html>");

            deleteDateFromFiles.setBounds(10, 260, 32,32);
            deleteDateFromFiles.setToolTipText("<html> Удалить данные </html>");

            openCellOfTable.setBounds(10, 320, 32,32);
            openCellOfTable.setToolTipText("<html> Открыть таблицу часов </html>");

            recoveryOfDate.setBounds(10, 380, 32,32);
            recoveryOfDate.setToolTipText("<html> Восстановить базу данных </html>");

            backUpOfData.setBounds(10, 440, 32,32);
            backUpOfData.setToolTipText("<html> Создание резервной копии данных </html>");

            boxSubjects.setBounds(70, 40, 225, 30);
            boxNames.setBounds(70, 80, 225, 30);
            boxGroups.setBounds(70, 120, 225, 30);
            generalLst.setBounds(330, 40, 360, 140);
            addDateToFile.setBounds(190, 170, 100, 30);
            createSchedule.setBounds(330, 190, 170, 30);
            sortOnClick.setBounds(750, 190, 120, 30);
            saveDataNotes.setBounds(940, 520, 110, 30);


            infoAboutAll.setBounds(750, 35, 350, 25);
            infoAboutAll.setFont(new Font("Tahoma", Font.BOLD, 14));
            infoAboutAll.setForeground(Color.WHITE);

            notesInfo.setBounds(550, 205, 225, 140);
            notesInfo.setFont(new Font("Tahoma", Font.BOLD, 14));
            notesInfo.setForeground(Color.WHITE);

            infoAboutNames.setBounds(750, 60, 350, 25);
            infoAboutNames.setFont(new Font("Tahoma", Font.BOLD, 14));
            infoAboutNames.setForeground(Color.WHITE);

            infoAboutGroups.setBounds(750, 120, 350, 25);
            infoAboutGroups.setFont(new Font("Tahoma", Font.BOLD, 14));
            infoAboutGroups.setForeground(Color.WHITE);

            infoAboutEvent.setBounds(10, 530, 300, 25);
            infoAboutEvent.setFont(new Font("Tahoma", Font.BOLD, 12));
            infoAboutEvent.setForeground(Color.WHITE);

            sortBoxNames.setBounds(750, 85, 225, 30);
            sortBoxGroups.setBounds(750, 145, 225, 30);
            viewSavedSchedule.setBounds(500, 190, 170, 30);



            JScrollPane scrollGeneralList = new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
                    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

            scrollGeneralList.getViewport().setBackground(Color.WHITE);
            scrollGeneralList.getViewport().add(generalLst);
            scrollGeneralList.setBounds(330, 40, 340, 140);


            JScrollPane scrollNotes = new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
                    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
            notes.setLineWrap(true);

            scrollNotes.getViewport().setBackground(Color.WHITE);
            scrollNotes.getViewport().add(notes);
            scrollNotes.setBounds(550, 301, 500, 208);

            ImageIcon backgroundImage = new ImageIcon("src/Background.jpg");

            mainFrame.add(pnlCalendar);
            mainFrame.add(backUpOfData);
            mainFrame.add(recoveryOfDate);
            mainFrame.add(openCellOfTable);
            mainFrame.add(printSavedTable);
            mainFrame.add(infoAboutEvent);
            mainFrame.add(notesInfo);
            mainFrame.add(saveDataNotes);
            mainFrame.add(scrollNotes);
            mainFrame.add(openFormSubjects);
            mainFrame.add(openFormNames);
            mainFrame.add(openFormGroups);
            mainFrame.add(infoAboutAll);
            mainFrame.add(infoAboutGroups);
            mainFrame.add(infoAboutNames);
            mainFrame.add(deleteDateFromFiles);
            mainFrame.add(scrollGeneralList);
            mainFrame.add(boxNames);
            mainFrame.add(boxSubjects);
            mainFrame.add(boxGroups);
            mainFrame.add(sortBoxNames);
            mainFrame.add(sortBoxGroups);
            mainFrame.add(addDateToFile);
            mainFrame.add(createSchedule);
            mainFrame.add(viewSavedSchedule);
            mainFrame.add(sortOnClick);
            mainFrame.add(new JLabel(backgroundImage));

            mainFrame.setSize(1200, 600);
            mainFrame.setResizable(false);
            mainFrame.setLocationRelativeTo(null);
            mainFrame.setVisible(false);
        }
        public static void refreshCalendar(int month, int year){

            String[] months =  {"Январь",
                    "Февраль",
                    "Март",
                    "Апрель",
                    "Май",
                    "Июнь",
                    "Июль",
                    "Август",
                    "Сентябрь",
                    "Октябрь",
                    "Ноябрь",
                    "Декабрь"};
            int nod, som;

            btnPrev.setEnabled(true);
            btnNext.setEnabled(true);
            if (month == 0 && year <= realYear - 10){btnPrev.setEnabled(false);}
            if (month == 11 && year >= realYear + 100){btnNext.setEnabled(false);}
            lblMonth.setText(months[month]);

            cmbYear.setSelectedItem(String.valueOf(year));

            for (int i=0; i < 6; i++){
                for (int j = 0; j < 7; j++){
                    mtblCalendar.setValueAt(null, i, j);
                }
            }

            GregorianCalendar cal = new GregorianCalendar(year, month, 1);
            nod = cal.getActualMaximum(GregorianCalendar.DAY_OF_MONTH);
            som = cal.get(GregorianCalendar.DAY_OF_WEEK);

            for (int i=1; i<=nod; i++){
                int row = new Integer((i+som-2)/7);
                int column  =  (i+som-2)%7;
                mtblCalendar.setValueAt(i, row, column);
            }

            tblCalendar.setDefaultRenderer(tblCalendar.getColumnClass(0), new tblCalendarRenderer());
        }

        static class tblCalendarRenderer extends DefaultTableCellRenderer{
            public Component getTableCellRendererComponent (JTable table, Object value, boolean selected, boolean focused, int row, int column){
                super.getTableCellRendererComponent(table, value, selected, focused, row, column);
                if (column == 0 || column == 6){
                    setBackground(new Color(255, 220, 220));
                }
                else {
                    setBackground(new Color(255, 255, 255));
                }
                if (value != null){
                    if (Integer.parseInt(value.toString()) == realDay && currentMonth == realMonth && currentYear == realYear){ //Today
                        setBackground(new Color(220, 220, 255));
                    }
                }
                setBorder(null);
                setForeground(Color.black);
                return this;
            }
        }

        static class btnPrev_Action implements ActionListener{
            public void actionPerformed (ActionEvent e){
                if (currentMonth == 0){
                    currentMonth = 11;
                    currentYear -= 1;
                }
                else {
                    currentMonth -= 1;
                }
                refreshCalendar(currentMonth, currentYear);
            }
        }
        static class btnNext_Action implements ActionListener{
            public void actionPerformed (ActionEvent e){
                if (currentMonth == 11){
                    currentMonth = 0;
                    currentYear += 1;
                }
                else {
                    currentMonth += 1;
                }
                refreshCalendar(currentMonth, currentYear);
            }
        }
        static class cmbYear_Action implements ActionListener{
            public void actionPerformed (ActionEvent e){
                if (cmbYear.getSelectedItem() != null){
                    String b = cmbYear.getSelectedItem().toString();
                    currentYear = Integer.parseInt(b);
                    refreshCalendar(currentMonth, currentYear);
                }
            }
        }
        public void viewSchedule() {

            isText = new JTextField(30);

            newModelForStorage = new DefaultTableModel();
            showDateForNew();
            TableSchedule = new JTable(newModelForStorage);
            countLinesGeneralForTable();
            refreshTable();

            TableSchedule.setVisible(true);
            frameOfTable = new JFrame("Табличное представление данных");
            frameOfTable.setIconImage(Toolkit.getDefaultToolkit().getImage("src/iconOfFrame.png"));
            lowPanel = new JPanel();

            if (condition.equals("LimitedMode")) {
                lowPanel.setVisible(false);
            }

            beginBuild = new JButton("Сохранить");
            beginBuild.addActionListener(new SaveForReturn());
            lowPanel.add(beginBuild);
            lowPanel.add(TableSchedule);

            pane = new JScrollPane(TableSchedule, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
                    ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
            TableSchedule.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);

            frameOfTable.add(BorderLayout.CENTER, pane);
            frameOfTable.add(BorderLayout.SOUTH, lowPanel);

            frameOfTable.setSize(900, 500);
            frameOfTable.setVisible(true);

            callBoxDataOfTable();
            OutputDateForNew(FILE_OF_REPOSITORY);
            TableSchedule.getColumnModel().getColumn(0).setPreferredWidth(90);
            TableSchedule.setRowHeight(40);
        }

        public void countLinesGeneralForTable() {

            linesCount = 0;

            try (LineNumberReader lnr = new LineNumberReader(new FileReader(FILE_OF_TABLE_BS))) {
                while (null != lnr.readLine()) {
                    linesCount++;
                }
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(null, "Данные не определенны "
                        + NAME_ERROR_TABLE);
            }
        }

        public void countLinesGeneralForTableOut() {
            linesCountForNew = 0;
            try (LineNumberReader lnr = new LineNumberReader(new FileReader(FILE_OF_REPOSITORY))) {
                while (null != lnr.readLine()) {
                    linesCountForNew++;
                }
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(null, "Данные не определенны "
                        + NAME_ERROR_TABLE_OF_SAVE);
            }
        }

        public void countLinesLocalForGroups() {

            try (LineNumberReader lnr = new LineNumberReader(new FileReader(FILE_OF_GROUPS))) {
                while (null != lnr.readLine()) {
                    linesCountsForGroups++;
                }
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(null, "Данные не определенны "
                        + NAME_ERROR_GROUPS);
            }
            listForGroups = new String[linesCountsForGroups];

            try  {
                BufferedReader reader = new BufferedReader(
                        new InputStreamReader(
                                new FileInputStream(FILE_OF_GROUPS), Charset.forName(ENCODING_UTF8)));;
                while ((line = reader.readLine()) != null) {
                    linesCountsForGroups--;
                    listForGroups[linesCountsForGroups] = line;
                }
                reader.close();
            } catch (IOException ex) {

            }

        }

        public void countLinesLocalForObjects() {

            try (LineNumberReader lnr = new LineNumberReader(new FileReader(FILE_OF_SUBJECTS))) {
                while (null != lnr.readLine()) {
                    linesCountsForSubjects++;
                }
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(null, "Данные не определенны "
                                                                             + NAME_ERROR_SUBJECTS);
            }

            listForSubjects = new String[linesCountsForSubjects];
          try {
              BufferedReader reader = new BufferedReader(
                      new InputStreamReader(
                              new FileInputStream(FILE_OF_SUBJECTS), Charset.forName(ENCODING_UTF8)));
              while ((line = reader.readLine()) != null) {
                  linesCountsForSubjects--;
                  listForSubjects[linesCountsForSubjects] = line;
              }
              reader.close();
             } catch (Exception ex) {

             }

        }

        public void countLinesLocalForName() {

            try (LineNumberReader lnr = new LineNumberReader(new FileReader("NamesList.txt"))) {
                while (null != lnr.readLine()) {
                    lineCountForNames++;
                }
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(null, "Данные не определенны "
                        + NAME_ERROR_NAMES);
            }
            listForNames = new String[lineCountForNames];


            try {
                BufferedReader reader = new BufferedReader(
                        new InputStreamReader(
                                new FileInputStream(FILE_OF_NAMES), Charset.forName(ENCODING_UTF8)));
                while ((line = reader.readLine()) != null) {
                    lineCountForNames--;
                    listForNames[lineCountForNames] = line;
                }
                reader.close();
            } catch (IOException ex) {

            }
        }

        public void OutputDate(String nameFile) {
            countLinesGeneralForTable();
            String[] timeLessons = new String[]{"08:20 - 08:50",
                                                "09:00 - 10:30",
                                                "10:45 - 12:15",
                                                "12:45 - 14:15",
                                                "14:30 - 16:00"};

            int counter = 0;
            int countLinesForStop = linesCount;
            int ColumnsGoTo = 0;
            int CountRowFromFile = 0;
            int linesGoTo = 0;
            int column = TableSchedule.getColumnCount();
            int countColumn = column;
            int countLessons = 0;
            int row = TableSchedule.getRowCount();
            try {
                BufferedReader reader = new BufferedReader(
                        new InputStreamReader(
                                new FileInputStream(FILE_OF_TABLE_BS), Charset.forName(ENCODING_UTF8)));

                while (!dateFromFile.equals(" ")) {
                    linesCount--;
                    try (Stream<String> lines = Files.lines(Paths.get(nameFile))) {
                        dateFromFile = lines.skip(linesGoTo).findFirst().get(); // back method through '-'
                        linesGoTo++;
                        counter++;
                        ColumnsGoTo++;
                    }
                    if (ColumnsGoTo == countColumn) {
                        CountRowFromFile++;
                        ColumnsGoTo = 1;
                        counter = 1;
                    }
                    if (countLessons == timeLessons.length) {
                        countLessons = 0;
                    }

                    if(CountRowFromFile == 0) {
                        model.addRow(new Object[]{timeLessons[countLessons], ""});
                        TableSchedule.setValueAt("", (counter - counter) + CountRowFromFile, counter);
                    } else {
                       // linesGoTo++;
                        model.addRow(new Object[]{timeLessons[countLessons], dateFromFile});
                        TableSchedule.setValueAt(dateFromFile, (counter - counter) + CountRowFromFile, counter);
                    }
                    System.out.print(CountRowFromFile + " ++");
                    countLessons++;
                }
                reader.close();
            } catch (Exception fileNotFound) {
                // JOptionPane.showMessageDialog(null, "No provide"); // Will be exception by reason of "while" above.
            }
          int valueOfDeleteRow = CountRowFromFile + 1;
            while (valueOfDeleteRow <= (countLinesForStop - 1)) {
                valueOfDeleteRow++;
                model.removeRow(CountRowFromFile + 1);
            }
        }

        public void OutputDateForNew(String nameFile) {
            countLinesGeneralForTableOut();
            String[] timeLessons = new String[]{"08:20 - 08:50",
                    "09:00 - 10:30",
                    "10:45 - 12:15",
                    "12:45 - 14:15",
                    "14:30 - 16:00"};

            int counter = 0;
            int countLinesForStop = linesCountForNew;
            int ColumnsGoTo = 0;
            int CountRowFromFile = 0;
            int linesGoTo = 0;
            int column = TableSchedule.getColumnCount();
            int countColumn = column;
            int countLessons = 0;

            if (stringWriteSort.isEmpty() && condition.equals("TurnOnSort")) {
                frameOfTable.setVisible(false);
                JOptionPane.showMessageDialog(null, INFO_ABOUT_WORK);
            }

            try {
                BufferedReader reader = new BufferedReader(
                        new InputStreamReader(
                                new FileInputStream(FILE_OF_REPOSITORY), Charset.forName(ENCODING_UTF8)));

                while (!dateFromFile.equals(" ")) {
                    linesCountForNew--;
                    try (Stream<String> lines = Files.lines(Paths.get(nameFile))) {
                        dateFromFile = lines.skip(linesGoTo).findFirst().get();
                        linesGoTo++;
                        counter++;
                        ColumnsGoTo++;
                    }

                    if (ColumnsGoTo == countColumn) {
                        CountRowFromFile++;
                        ColumnsGoTo = 1;
                        counter = 1;
                    }

                    if (countLessons == 3) {
                        countLessons = 0;
                    }

                    newModelForStorage.addRow(new Object[]{timeLessons[countLessons], dateFromFile, "", "", "", ""});
                    TableSchedule.setValueAt(dateFromFile, (counter - counter) + CountRowFromFile, counter);
                    countLessons++;

                    if (condition.equals("TurnOnSort")) {

                        if (!stringWriteSort.isEmpty()) {

                            Object valueOf = TableSchedule.getValueAt((counter - counter) + CountRowFromFile, counter);
                            String toStringOfValue = valueOf.toString();

                            StringTokenizer skipObjectValue = new StringTokenizer(toStringOfValue);
                            String firstArgOfObject = skipObjectValue.hasMoreTokens() ? skipObjectValue.nextToken() : "";
                            String secondArgOfObject = skipObjectValue.hasMoreTokens() ? skipObjectValue.nextToken() : "";
                            String emptyValueOfObject = skipObjectValue.hasMoreTokens() ? skipObjectValue.nextToken() : ""; // never use, need for work of "thirdValue"
                            String thirdValueOfObject = skipObjectValue.hasMoreTokens() ? skipObjectValue.nextToken() : "";


                            StringTokenizer skipStringBoxes = new StringTokenizer(stringWriteSort);
                            String firstArg = skipStringBoxes.hasMoreTokens() ? skipStringBoxes.nextToken() : "";
                            String secondArg = skipStringBoxes.hasMoreTokens() ? skipStringBoxes.nextToken() : "";
                            String emptyValue = skipStringBoxes.hasMoreTokens() ? skipStringBoxes.nextToken() : ""; // never use, need for work of "thirdValue"
                            String thirdValue = skipStringBoxes.hasMoreTokens() ? skipStringBoxes.nextToken() : "";


                            if (firstArgOfObject.equals(firstArg) || thirdValueOfObject.equals(thirdValue)) {
                                TableSchedule.setValueAt(toStringOfValue, (counter - counter) + CountRowFromFile, counter);

                            }

                            else {
                                TableSchedule.setValueAt("", (counter - counter) + CountRowFromFile, counter);
                            }
                        }
                    }
                }
                reader.close();

            } catch(Exception fileNotFound){
                // JOptionPane.showMessageDialog(null, "No provide"); // Might be exception by reason of "while" above.
            }
            int valueOfDeleteRow = CountRowFromFile + 1;
            while (valueOfDeleteRow <= (countLinesForStop - 1)) {
                valueOfDeleteRow++;
                newModelForStorage.removeRow(CountRowFromFile + 1);
            }

        }

        public void refreshTable() {
            JTableHeader th = TableSchedule.getTableHeader();
            for (int i = 0; i < TableSchedule.getColumnCount(); i++) {
                TableColumn column = TableSchedule.getColumnModel().getColumn(i);
                int prefWidth = Math.round((float) th.getFontMetrics(th.getFont())
                        .getStringBounds(th.getTable().getColumnName(i),
                                th.getGraphics()).getWidth());
                column.setPreferredWidth(prefWidth + 260);
            }
        }

        public void callBoxDataOfTable() {
            JComboBox<String> data = new JComboBox<>(new String[] {});
            Storage = new DefaultCellEditor(data);
            for (int x = 1; x <= 6; x++)
                TableSchedule.getColumnModel().getColumn(x).setCellEditor(Storage);
            try (FileReader na = new FileReader(FILE_OF_TABLE_BS)) {
                BufferedReader reader = new BufferedReader(na);
                na.getEncoding();
                while (DataForTable != null) {
                    data.addItem(DataForTable);
                    DataForTable = reader.readLine();
                }
                reader.close();
            } catch (Exception fileNotFound) {
                JOptionPane.showMessageDialog(null, MASSAGE_ERROR_NOT_FOUND_FILE);
            }
            DataForTable = "";
        }


        public void ColumnsCellOfTable() {
            countLinesLocalForGroups();
            int lengthOfList = listForGroups.length;
            for(String counter : listForGroups) {
                if(lengthOfList >= listForGroups.length) {
                    lengthOfList--;
                    th_call.addColumn(NAME_ERROR_SUBJECTS);
                    th_call.addColumn(counter);
                }
                else
                    th_call.addColumn(counter);
            }
        }
        public void showDate () {
            String[] daysOfWeek = {"Пары",
                                   "Понедельник",
                                   "Вторник",
                                   "Среда",
                                   "Четверг",
                                   "Пятница",
                                   "Суббота"};

            for(String counter : daysOfWeek) {
                model.addColumn(counter);
            }
        }

        public void clearFileForSave() {
            try (FileWriter write = new FileWriter(FILE_OF_REPOSITORY)) {
                write.write("");
            }
            catch (IOException e) {
                JOptionPane.showMessageDialog(null, MASSAGE_ERROR_NOT_FOUND_FILE);
            }
        }

        public void showDateForNew() {
            String[] daysOfWeek = {"Пары",
                    "Понедельник",
                    "Вторник",
                    "Среда",
                    "Четверг",
                    "Пятница",
                    "Суббота"};

            for(String counter : daysOfWeek) {
                newModelForStorage.addColumn(counter);
            }
        }

        public void refreshTableOfHours(int valueOfWight) {
            JTableHeader th = tableHours.getTableHeader();

            for (int i = 0; i < tableHours.getColumnCount(); i++) {
                TableColumn column = tableHours.getColumnModel().getColumn(i);
                int prefWidth = Math.round((float) th.getFontMetrics(th.getFont())
                        .getStringBounds(th.getTable().getColumnName(i),
                                th.getGraphics()).getWidth());
                column.setPreferredWidth(prefWidth + valueOfWight);
            }
        }

        public void actionPerformed(ActionEvent event) {
            String textGroups = (String)boxGroups.getSelectedItem();
            String textObjects = (String)boxSubjects.getSelectedItem();
            String textNames = (String)boxNames.getSelectedItem();

            stringWrite = textGroups + " " + textObjects + " " + textNames;
            System.out.println(stringWrite + " ");



            String sortTextGroups = (String)sortBoxGroups.getSelectedItem();
            String sortTextNames = (String)sortBoxNames.getSelectedItem();

            stringWriteSort = sortTextGroups + " " + textObjects + " " + sortTextNames;
            System.out.println(stringWriteSort + " ");
        }

        public void countLinesForTable() {
            String checkOnEmpty = "";
            try {
                FileReader file = new FileReader(FILE_OF_TABLE_HOURS);
                BufferedReader reader = new BufferedReader(file);
                checkOnEmpty = reader.readLine();
                file.close();
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(null, "Данные не определенны "
                        + NAME_ERROR_TABLE_OF_HOURS);
            }

            if(checkOnEmpty == null) {
                try {
                    FileWriter file = new FileWriter(FILE_OF_TABLE_HOURS);
                    file.write("\n");
                    System.out.println(" !@# ");
                    file.close();
                } catch (IOException ex) {
                    JOptionPane.showMessageDialog(null, "Данные не определенны "
                            + NAME_ERROR_TABLE_OF_HOURS);
                }
            }
            linesCount = 0;

            try (LineNumberReader lnr = new LineNumberReader(new FileReader(FILE_OF_TABLE_HOURS))) {

                while (null != lnr.readLine()) {
                    linesCount++;
                }
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(null, "Данные не определенны "
                        + NAME_ERROR_TABLE_OF_HOURS);
            }

        }

        public void OutputDataOf_TOH(String nameFile) {
            countLinesForTable();

            int counter = 0;
            int ColumnsGoTo = 0;
            int CountRowFromFile = 0;
            int linesGoTo = 0;
            int column = tableHours.getColumnCount();
            int countColumn = column;

            try (FileReader file = new FileReader(nameFile)) {
                BufferedReader reader = new BufferedReader(file);
                while (!dateFromFile.equals(" ")) {
                    linesCountForNew--;

                    try (Stream<String> lines = Files.lines(Paths.get(nameFile))) {
                        dateFromFile = lines.skip(linesGoTo).findFirst().get();
                        linesGoTo++;
                        counter++;
                        ColumnsGoTo++;
                    }

                    if (ColumnsGoTo == countColumn) {
                        CountRowFromFile++;
                        ColumnsGoTo = 1;
                        counter = 1;
                    }

                    for(String counters : listForSubjects) {
                        th_call.addRow(new Object[]{counters});
                    }
                    //th_call.addRow(new Object[]{dateFromFile});

                    tableHours.setValueAt(dateFromFile, (counter - counter) + CountRowFromFile, counter);
                }
                reader.close();

            } catch(Exception fileNotFound){
                // JOptionPane.showMessageDialog(null, "No provide"); // Might be exception by reason of "while" above.
            }
            countLinesLocalForObjects();

            int countRows = tableHours.getRowCount();
            countRows--;

            while (countRows != listForSubjects.length - 1) {
                th_call.removeRow(countRows);
                countRows--;
            }
        }

    }
    static public class CellOfTable extends TableDate implements ActionListener {

        public void actionPerformed(ActionEvent event) {

            JFrame frame_th = new JFrame("Сетка часов");
            frame_th.setIconImage(Toolkit.getDefaultToolkit().getImage("src/iconOfFrame.png"));

            JPanel panelPfButtons = new JPanel();
            saveTableOfHours = new JButton("Сохранить");
            saveTableOfHours.addActionListener(new SaveTableOfHours());

            if(condition.equals("LimitedMode")) {
                saveTableOfHours.setVisible(false);
            }

            th_call = new DefaultTableModel();
            ColumnsCellOfTable();
            tableHours = new JTable(th_call);

            int wightColumn = 50;
            int columns = tableHours.getColumnCount();
            for(int x = 0; x < columns; x++) {
                if(x != 0) {
                    tableHours.getColumnModel().getColumn(x).setPreferredWidth(wightColumn);
                }
                else {
                    wightColumn = wightColumn + 20;
                    tableHours.getColumnModel().getColumn(x).setPreferredWidth(wightColumn);
                }
            }
            tableHours.setRowHeight(40);
            refreshTableOfHours(wightColumn);

            countLinesLocalForObjects();
            OutputDataOf_TOH(FILE_OF_TABLE_HOURS);

            panelPfButtons.add(saveTableOfHours);
            frame_th.add(BorderLayout.SOUTH, panelPfButtons);
            frame_th.add(tableHours);

            pane = new JScrollPane(tableHours, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
                    ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
            tableHours.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);

            frame_th.add(BorderLayout.CENTER, pane);
            frame_th.setSize(1280,720);
            frame_th.setVisible(true);
            frame_th.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        }
    }

    static public class SaveTableOfHours extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent e) {

            clearContentForSave();

            int column = tableHours.getColumnCount();
            int row = tableHours.getRowCount();

            for (int x = 0; x < row; x++) {
                for (int y = 1; y < column; y++) {
                    saveTable = tableHours.getValueAt(x, y);
                    System.out.print("[ " + saveTable + "] ");
                    try {
                        FileWriter write = new FileWriter("TableOfHours.txt", true);
                        write.write(saveTable + "\n");
                        write.close();
                        infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
                    } catch (IOException ex) {
                        JOptionPane.showMessageDialog(null, "Файл не найден");
                        infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
                    }
                }
            }
            saveTable = "";
        }

        private void clearContentForSave() {
            try {
                FileWriter write = new FileWriter("TableOfHours.txt"); // create var
                write.write("");
                write.close();
                infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(null, "Файл не найден");
                infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
            }
        }
    }
    static public class PrintTable extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent ev) {

            JFrame frameOfSelectPrint = new JFrame("Выбор таблицы для печати");
            frameOfSelectPrint.setIconImage(Toolkit.getDefaultToolkit().getImage("src/iconOfFrame.png"));

            ImageIcon iconPrint = new ImageIcon("src/print_at_frame_FOP.png");
            JLabel contentIcon = new JLabel(iconPrint);
            String tableOfHours = "Таблица часов";
            String savedTable = "Сохраненная таблица расписания";

            String[] tablesOfData = new String[] {"- Выберите таблицу для печати -",
                    tableOfHours,
                    savedTable};

            JComboBox<String> tables = new JComboBox<>(tablesOfData);

            tables.addItemListener(new ItemListener() {
                public void itemStateChanged(ItemEvent event) {
                    if (event.getStateChange() == ItemEvent.SELECTED) {
                        Object item = event.getItem();
                        frameOfSelectPrint.dispose();
                        if(item.equals(savedTable)) {
                            BuildSchedule isStartTableSchedule = new BuildSchedule();
                            isStartTableSchedule.actionPerformed(ev);

                            try {
                                TableSchedule.print(JTable.PrintMode.FIT_WIDTH);

                            } catch (Exception ex) {
                                JOptionPane.showMessageDialog(null, ATTENTION_NOT_SELECTED_TABLE);
                            }
                        }

                        if(item.equals(tableOfHours)) {
                            CellOfTable isStartTAbleOfHours = new CellOfTable();
                            isStartTAbleOfHours.actionPerformed(ev);

                            try {
                                tableHours.print(JTable.PrintMode.FIT_WIDTH);
                            } catch (Exception ex) {
                                JOptionPane.showMessageDialog(null, ATTENTION_NOT_SELECTED_TABLE);
                            }
                        }

                    }
                }
            });

            frameOfSelectPrint.add(contentIcon);
            frameOfSelectPrint.add(tables);


            contentIcon.setBounds(10,10,48,48);
            tables.setBounds(80,20, 240, 30);
            frameOfSelectPrint.setSize(400, 130);


            frameOfSelectPrint.setLayout(null);
            frameOfSelectPrint.setLocationRelativeTo(null);
            frameOfSelectPrint.setResizable(false);
            frameOfSelectPrint.setVisible(true);

        }
    }


    static class AddDate extends Main.TableDate implements ActionListener {
        public void actionPerformed(ActionEvent event) {

            generalLst.append(stringWrite + "\n");
            generalLst.append("-------------------------------------------------------------------------------" + "\n");

            System.out.print("adding line is --> [" + stringWrite + "]\n");


            try  {
                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
                        new FileOutputStream(FILE_OF_TABLE_BS, true), "UTF8"));
                bw.write(stringWrite + "\n");
                bw.flush();
            }
            catch (IOException e) {
                JOptionPane.showMessageDialog(null, "Запись не может быть завершена");
            }
        }
    }

    static class CheckingAuth extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent e) {
            showPanelCreateAccount();
        }
    }
    static class ContinueSI extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent e) {

            String localCheck = passwordUserCheck.getText();

            if(localCheck.equals(checkSignIn)) {
                condition = "AccessAllow";
                authorization.dispose();
                mainFrame.setVisible(true);
                passwordUserCheck.setBorder(BorderFactory.createLineBorder(COLOR_BORDER_SUCCESS));
            }
            else
                condition = "NoAccess";

            System.out.println("Current condition [" + condition + "]");


            if (localCheck.isEmpty()) {
                condition = "LimitedMode";
                createSchedule.setEnabled(false);
                openFormSubjects.setEnabled(false);
                openFormGroups.setEnabled(false);
                openFormNames.setEnabled(false);
                deleteDateFromFiles.setEnabled(false);
                addDateToFile.setEnabled(false);
                boxNames.setEnabled(false);
                boxGroups.setEnabled(false);
                boxSubjects.setEnabled(false);
                backUpOfData.setEnabled(false);
                recoveryOfDate.setEnabled(false);
                authorization.dispose(); // using this method for clear RAM
                mainFrame.setVisible(true);
                System.out.println("Current condition [" + condition + "]");
            }

            if (!localCheck.equals(checkSignIn) & !localCheck.isEmpty()) {
                passwordUserCheck.setBorder(BorderFactory.createLineBorder(COLOR_BORDER_WRONG));
            }


        }
    }
    static class CheckingDate extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent e) {
            String passOriginal = passwordUser.getText();
            String passRepeat = repeatPU.getText();

            if(passOriginal.equals(passRepeat)) {
                if(passOriginal.isEmpty()) {
                    JOptionPane.showMessageDialog(null, "Поля должны быть заполненны!");
                    return;
                }

                passwordUser.setBorder(BorderFactory.createLineBorder(COLOR_BORDER_SUCCESS));
                repeatPU.setBorder(BorderFactory.createLineBorder(COLOR_BORDER_SUCCESS));
                System.out.print("Success! Access is allowed\n");
                icon.setVisible(true);
                checkSignIn = passOriginal;
                passwordUser.setText("");
                repeatPU.setText("");

                try (FileWriter saveUserDate = new FileWriter("UserOfDate.txt")) {
                    saveUserDate.write(passOriginal + "\n");
                } catch (Exception ex) {
                    JOptionPane.showMessageDialog(null, "Данные не определенны");
                }
                signIn.setEnabled(true);
            }

            else {
                passwordUser.setBorder(BorderFactory.createLineBorder(COLOR_BORDER_WRONG));
                repeatPU.setBorder(BorderFactory.createLineBorder(COLOR_BORDER_WRONG));
                System.out.print("Error, values [" + passOriginal + "] " +
                        "&" +
                        " [" + passRepeat + "] don`t coincidence\n");
                passwordUser.setText("");
                repeatPU.setText("");
            }
        }
    }

    static class OpenFormSubject extends TableDate implements ActionListener {
        JFrame FrameForSubjects;
        JButton addDate;
        JPanel panelOfComponents;

        static JTextField textForSubjects;
        static String save;
        static JLabel labelInfoFrame;

        static JLabel placeForConfirmation;

        public void actionPerformed(ActionEvent event) {
            labelInfoFrame = new JLabel("Запишите дисциплину для сохранения");
            addDate = new JButton("Сохранить");

            placeForConfirmation = new JLabel(new ImageIcon("src/confirmation.png"));
            placeForConfirmation.setVisible(false);
            textForSubjects = new JTextField();

            labelInfoFrame.setFont(new Font("Tahoma", Font.PLAIN, 13));
            panelOfComponents = new JPanel();
            panelOfComponents.setLayout(null);
            labelInfoFrame.setBounds(30, 15, 240, 25);
            textForSubjects.setBounds(30, 50, 240, 28);

            placeForConfirmation.setBounds(270, 20, 100, 50);
            addDate.setBounds(130, 80, 140, 27);

            panelOfComponents.add(labelInfoFrame);
            panelOfComponents.add(textForSubjects);
            panelOfComponents.add(placeForConfirmation);
            panelOfComponents.add(addDate);

            FrameForSubjects = new JFrame("Добавить дисциплину");
            FrameForSubjects.setIconImage(Toolkit.getDefaultToolkit().getImage("src/iconOfFrame.png"));

            FrameForSubjects.add(panelOfComponents);
            FrameForSubjects.setSize(400, 160);

            FrameForSubjects.setLocationRelativeTo(null);
            FrameForSubjects.setResizable(false);
            FrameForSubjects.setVisible(true);

            addDate.addActionListener(new SaveSubjects());
        }

        public void writeDate(String dataObjects) {

            try {
                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
                        new FileOutputStream(FILE_OF_SUBJECTS, true), "UTF8"));
                bw.write(dataObjects + "\n");
                bw.flush();

            } catch (Exception ex) {
                JOptionPane.showMessageDialog(null, MASSAGE_ERROR_NOT_FOUND_FILE +
                                                                             " " + NAME_ERROR_SUBJECTS);
            }
            countLinesLocalForObjects();
        }
    }

    static class OpenFormNames extends TableDate implements ActionListener {
        JFrame frameForNames;
        JButton addDate;
        JPanel panelOfComponents;

        static JTextField textForNames;
        static String save;
        static JLabel labelInfo;
        static JLabel placeForConfirmation;

        public void actionPerformed(ActionEvent event) {
            labelInfo = new JLabel("Запишите имя для сохранения");
            addDate = new JButton("Сохранить");
            textForNames = new JTextField();

            placeForConfirmation = new JLabel(new ImageIcon("src/confirmation.png"));
            panelOfComponents = new JPanel();
            placeForConfirmation.setVisible(false);
            panelOfComponents.setLayout(null);

            labelInfo.setFont(new Font("Tahoma", Font.PLAIN, 13));

            labelInfo.setBounds(20, 20, 225, 20);
            textForNames.setBounds(20, 50, 225, 28);
            placeForConfirmation.setBounds(270, 20, 100, 50);
            addDate.setBounds(120, 80, 125, 27);

            panelOfComponents.add(textForNames);
            panelOfComponents.add(labelInfo);
            panelOfComponents.add(addDate);
            panelOfComponents.add(placeForConfirmation);

            frameForNames = new JFrame("Добавить имя");
            frameForNames.setIconImage(Toolkit.getDefaultToolkit().getImage("src/iconOfFrame.png"));

            frameForNames.add(panelOfComponents);
            frameForNames.setSize(400, 160);
            frameForNames.setVisible(true);

            addDate.addActionListener(new SaveNames());
            frameForNames.setLocationRelativeTo(null);
            frameForNames.setResizable(false);

        }
        public void writeDate(String dataNames) {
          try  {
                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
                        new FileOutputStream(FILE_OF_NAMES, true), "UTF8"));
                bw.write(dataNames + "\n");
                bw.flush();
            }
            catch (Exception fileNotFound) {
                JOptionPane.showMessageDialog(null, MASSAGE_ERROR_NOT_FOUND_FILE +
                        " " + NAME_ERROR_NAMES);
            }
            countLinesLocalForName();
        }

    }
    static class OpenFormGroups extends TableDate implements ActionListener {
        JFrame FrameForGroups;
        JButton addDate;
        JPanel panelOfComponents;

        static JTextField textForGroups;
        static String save;
        static JLabel labelInfo;
        static JLabel placeForConfirmation;

        public void actionPerformed(ActionEvent event) {

            labelInfo = new JLabel("Запишите группу для сохранения");

            addDate = new JButton("Сохранить");

            textForGroups = new JTextField();
            placeForConfirmation = new JLabel(new ImageIcon("src/confirmation.png"));
            placeForConfirmation.setVisible(false);
            labelInfo.setFont(new Font("Tahoma", Font.PLAIN, 13));
            panelOfComponents = new JPanel();
            panelOfComponents.setLayout(null);

            panelOfComponents.add(labelInfo);
            panelOfComponents.add(textForGroups);
            panelOfComponents.add(placeForConfirmation);
            panelOfComponents.add(addDate);

            labelInfo.setBounds(20, 20, 225, 20);
            textForGroups.setBounds(20, 50, 225, 28);
            placeForConfirmation.setBounds(270, 20, 100, 50);
            addDate.setBounds(120, 80, 125, 27);


            FrameForGroups = new JFrame("Добавить группу в список");
            FrameForGroups.setIconImage(Toolkit.getDefaultToolkit().getImage("src/iconOfFrame.png"));

            FrameForGroups.setSize(400, 160);
            FrameForGroups.add(panelOfComponents);
            FrameForGroups.setLocationRelativeTo(null);
            FrameForGroups.setResizable(false);
            FrameForGroups.setVisible(true);

            addDate.addActionListener(new SaveGroups());
        }

        public void writeDate(String dataGroups) {
            try {
                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
                        new FileOutputStream(FILE_OF_GROUPS, true), "UTF8"));
                bw.write(dataGroups + "\n");
                bw.flush();
            }
            catch (Exception fileNotFound) {
                JOptionPane.showMessageDialog(null, MASSAGE_ERROR_NOT_FOUND_FILE +
                                                                             " " + NAME_ERROR_GROUPS);
            }
            countLinesLocalForGroups();
        }
    }
    static class BuildSchedule extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent event) {

            isText = new JTextField(30);

            model = new DefaultTableModel();
            showDate();
            TableSchedule = new JTable(model);

            countLinesGeneralForTable();
            refreshTable();
            TableSchedule.setVisible(true);

            frameOfTable = new JFrame("Созданное расписание");
            frameOfTable.setIconImage(Toolkit.getDefaultToolkit().getImage("src/iconOfFrame.png"));

            lowPanel = new JPanel();

            beginBuild = new JButton("Сохранить");
            viewSavedSchedule = new JButton("Просмотр");

            viewSavedSchedule.addActionListener(new ViewSaveSchedule());
            beginBuild.addActionListener(new SaveForReturn());

            lowPanel.add(TableSchedule);


            lowPanel.add(beginBuild, BoxLayout.Y_AXIS);
            lowPanel.add(viewSavedSchedule);

            frameOfTable.add(BorderLayout.SOUTH, lowPanel);
            OutputDate(FILE_OF_TABLE_BS);
            callBoxDataOfTable();
            pane = new JScrollPane(TableSchedule, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
                    ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
            TableSchedule.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);

            frameOfTable.add(BorderLayout.CENTER, pane);

            frameOfTable.setSize(900, 500);

            frameOfTable.setVisible(true);

            TableSchedule.getColumnModel().getColumn(0).setPreferredWidth(90);
            TableSchedule.setRowHeight(40);
        }
    }
    static class BackUpOfDate extends TableDate implements ActionListener {
        static JFrame frameOfBackUp;
        public void actionPerformed(ActionEvent event) {
            frameOfBackUp = new JFrame("Создание резервной копии");
            frameOfBackUp.setLayout(null);

            JLabel iconDownload = new JLabel(new ImageIcon("src/download.png"));
            JLabel iconUnload = new JLabel(new ImageIcon("src/unload.png"));
            JLabel interaction = new JLabel(new ImageIcon("src/interaction.png"));

            JButton uploadDataOfBackUp = new JButton("Выгрузить"); // output from program
            JButton downloadDataOfBackUp = new JButton("Загрузить"); // input to program

            uploadDataOfBackUp.addActionListener(new Unload());
            downloadDataOfBackUp.addActionListener(new Download());

            interaction.setBounds(200, 15, 100,100);
            iconDownload.setBounds(345, 15, 100,100);
            iconUnload.setBounds(50, 15, 100,100);

            uploadDataOfBackUp.setBounds(50, 120, 100,30);
            downloadDataOfBackUp.setBounds(345, 120, 100,30);

            progressBar = new JProgressBar();
            progressBar.setBounds(0, 180, 483,30);

            frameOfBackUp.add(progressBar);

            frameOfBackUp.add(uploadDataOfBackUp);
            frameOfBackUp.add(interaction);
            frameOfBackUp.add(downloadDataOfBackUp);

            frameOfBackUp.add(iconDownload);
            frameOfBackUp.add(iconUnload);

            frameOfBackUp.setSize(500, 250);
            frameOfBackUp.setResizable(false);
            frameOfBackUp.setLocationRelativeTo(null);
            frameOfBackUp.setVisible(true);
        }
    }

    static class Unload extends BackUpOfDate implements ActionListener {

        public void actionPerformed(ActionEvent event) {
            String[] listFiles_Storage = {"Repository",
                    "DoneSchedule",
                    "NamesList",
                    "GroupsList",
                    "SubjectsList",
                    "TableOfHours"};


            progressBar.setStringPainted(true);
            progressBar.setMinimum(0);
            progressBar.setMaximum(100);

            for (int i = 0; i <= 100; i++) {
                progressBar.setValue(i);
            }
            try {

                Unload("[" + listFiles_Storage[0] + "].txt", FILE_OF_REPOSITORY);
                Unload("[" + listFiles_Storage[1] + "].txt", FILE_OF_TABLE_BS);
                Unload("[" + listFiles_Storage[2] + "].txt", FILE_OF_NAMES);
                Unload("[" + listFiles_Storage[3] + "].txt", FILE_OF_GROUPS);
                Unload("[" + listFiles_Storage[4] + "].txt", FILE_OF_SUBJECTS);
                Unload("[" + listFiles_Storage[5] + "].txt", FILE_OF_TABLE_HOURS);

            } catch (Exception ex) {
                JOptionPane.showMessageDialog(null, "Не удалось завершить операцию! ");
                progressBar.setVisible(false);
                infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
            }

            infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
            JOptionPane.showMessageDialog(null, "Данные выгружены! ");
            frameOfBackUp.dispose();
        }
    }

    static class Download extends BackUpOfDate implements ActionListener {

        public void actionPerformed(ActionEvent event) {
            String[] listFiles_Storage = {"Repository",
                    "DoneSchedule",
                    "NamesList",
                    "GroupsList",
                    "SubjectsList",
                    "TableOfHours"};

            progressBar.setStringPainted(true);
            progressBar.setMinimum(0);
            progressBar.setMaximum(100);

            for(int i = 0; i <= 100; i ++) {
                progressBar.setValue(i);
            }

            try {
                Unload(FILE_OF_REPOSITORY, "[" + listFiles_Storage[0] + "].txt");
                Unload(FILE_OF_TABLE_BS, "[" + listFiles_Storage[1] + "].txt");
                Unload(FILE_OF_NAMES, "[" + listFiles_Storage[2] + "].txt");
                Unload(FILE_OF_GROUPS,"[" + listFiles_Storage[3] + "].txt");
                Unload(FILE_OF_SUBJECTS,"[" + listFiles_Storage[4] + "].txt");
                Unload(FILE_OF_TABLE_HOURS,"[" + listFiles_Storage[5] + "].txt");
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(null, "Не удалось завершить операцию! ");
                progressBar.setVisible(false);
                infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
            }
            finally {
                try {
                    JOptionPane.showMessageDialog(null, "Для продолжения, программа требует перезагрузки");
                    Thread.sleep(3000);
                    System.exit(0);
                } catch (Exception ex) {

                }
            }
            infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
            JOptionPane.showMessageDialog(null, "Данные загружены! ");

            frameOfBackUp.dispose();
        }
    }
    public static void Unload(String sourcePath, String destinationPath) throws IOException { // method for back up
        Files.copy(Paths.get(sourcePath), new FileOutputStream(destinationPath));
    }

    static class FormOfRecovery extends TableDate implements ActionListener {
        static JProgressBar progressOfRecovery;
        static JFrame frameOfRecovery;
        public void actionPerformed(ActionEvent event) {

            frameOfRecovery = new JFrame("Восстановление");
            frameOfRecovery.setLayout(null);

            ImageIcon iconCreateNewData = new ImageIcon("src/add_new_data.png");
            JLabel labelOfIcon = new JLabel(iconCreateNewData);

            JButton confirmation = new JButton("Да");
            JButton renouncement = new JButton("Нет");

            confirmation.addActionListener(new RecoveryOfData());
            renouncement.addActionListener(new CancelOperation());

            JLabel infoCreateNewData = new JLabel(INFO_RECOVERY);

            labelOfIcon.setBounds(10,10, 100,100);
            infoCreateNewData.setBounds(130,10,300,130);

            confirmation.setBounds(130,150,100,30);
            renouncement.setBounds(250,150,100,30);

            progressOfRecovery = new JProgressBar();
            progressOfRecovery.setBounds(0, 232, 483, 30);

            frameOfRecovery.add(progressOfRecovery);
            frameOfRecovery.add(labelOfIcon);
            frameOfRecovery.add(confirmation);
            frameOfRecovery.add(renouncement);
            frameOfRecovery.add(infoCreateNewData);

            frameOfRecovery.setSize(500, 300);
            frameOfRecovery.setResizable(false);
            frameOfRecovery.setLocationRelativeTo(null);
            frameOfRecovery.setVisible(true);

        }
    }
    static class CancelOperation extends FormOfRecovery implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            JOptionPane.showMessageDialog(null, "Операция отменена!");
            infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
            frameOfRecovery.dispose();
        }
    }
    static class RecoveryOfData extends FormOfRecovery implements ActionListener {
        public void actionPerformed(ActionEvent event) {

            String[] listFiles = {"Repository.txt",
                    "DoneSchedule.txt",
                    "NamesList.txt",
                    "GroupsList.txt",
                    "SubjectsList.txt",
                    "Check.txt",
                    "TableOfHours.txt",
                    "DataNotes.txt"};

            progressOfRecovery.setStringPainted(true);
            progressOfRecovery.setMinimum(0);
            progressOfRecovery.setMaximum(100);

            for(int i = 0; i <= 100; i ++) {
                progressOfRecovery.setValue(i);
            }

            for (String createFiles : listFiles) {
                try (FileWriter createFile = new FileWriter(createFiles)) {
                    createFile.write("");
                } catch (Exception ex) {
                    JOptionPane.showMessageDialog(null, "Операция не может быть завершена");
                    infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
                }
            }
            JOptionPane.showMessageDialog(null, "Восстановление завершено!");
            infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
            frameOfRecovery.dispose();
        }
    }
    static class SaveDataNotes extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            dataNotes = notes.getText();

            try {
                FileWriter write = new FileWriter("DataNotes.txt", false);
                write.write(dataNotes);
                write.close();
                infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
            } catch (IOException e) {
                JOptionPane.showMessageDialog(null, "Данные не могут быть записаны");
                infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
            }


        }

    }
    static class SaveForReturn extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            String checkForAvailability = "";
            try (FileReader read = new FileReader("Check.txt")) {
                BufferedReader buffer =  new BufferedReader(read);
                checkForAvailability = buffer.readLine();
            } catch (IOException e) {
                JOptionPane.showMessageDialog(null, "Данные не могут быть записаны");
            }

            if(checkForAvailability != null) {
                Object[] options = {"Да",
                                    "Нет"};
                int userChoice = JOptionPane.showOptionDialog(frameOfTable,
                        "Желаете перезаписать предыдущие данные?",
                        "Сохранение",
                        JOptionPane.YES_NO_CANCEL_OPTION,
                        JOptionPane.QUESTION_MESSAGE,
                        null,
                        options,
                        options[1]);

                if (userChoice == 0) {
                    saveData();
                    JOptionPane.showMessageDialog(null, "Сохранение завершено!");
                } else {
                    JOptionPane.showMessageDialog(null, "Сохранение отменено!");
                }
            }

            String date = "data of file is`n empty";
            try (FileWriter write = new FileWriter(FILE_CHECK_SAVE_DATE)) {
                write.write(date);
            } catch (IOException e) {
                JOptionPane.showMessageDialog(null, "Данные не могут быть записаны");
                infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
            }
            if(checkForAvailability == null) {
                saveData();
                JOptionPane.showMessageDialog(null, "Сохранение завершено!");
                infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
            }
        }

        public void saveData() {
            clearFileForSave();

            int column = TableSchedule.getColumnCount();
            int row = TableSchedule.getRowCount();

            for (int x = 0; x < row; x++) {
                for (int y = 1; y < column; y++) {
                    saveTable = TableSchedule.getValueAt(x, y);
                    System.out.print("[ " + saveTable + "] ");
                    try {
                        BufferedWriter writingData = new BufferedWriter(new OutputStreamWriter(
                                new FileOutputStream(FILE_OF_REPOSITORY, true), "UTF8"));
                        writingData.write(saveTable + "\n");
                        writingData.flush();
                        infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
                    } catch (IOException e) {
                        JOptionPane.showMessageDialog(null, "Файл не найден");
                        infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
                    }
                }
            }
        }
    }
    static class SortDate extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent e) {
            if(!condition.equals("LimitedMode")) {
                condition = "TurnOnSort";
            }
            viewSchedule();
        }
    }
    static class ViewSaveSchedule extends TableDate implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            if(!condition.equals("LimitedMode")) {
                condition = "TurnOffSort";
            }
            viewSchedule();
        }
    }
}

class SaveGroups extends Main.OpenFormGroups implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        save = textForGroups.getText();
        labelInfo.setForeground(COLOR_BORDER_SUCCESS);
        if(save.isEmpty()) {
            labelInfo.setText("Поле не должно быть пустым!");
            labelInfo.setForeground(COLOR_BORDER_WRONG);
            infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
            return;
        }
        else
            labelInfo.setText("Группа '" + textForGroups.getText() + "' сохранено");
        placeForConfirmation.setVisible(true);
        writeDate(save);
        infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
        textForGroups.setText("");

        sortBoxGroups.removeAllItems();
        boxGroups.removeAllItems();

        for(String counter : listForGroups) {
            boxGroups.addItem(counter);
            sortBoxGroups.addItem(counter);
        }
    }

}
class SaveNames extends Main.OpenFormNames implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        save = textForNames.getText();

        labelInfo.setForeground(COLOR_BORDER_SUCCESS);

        if(save.isEmpty()) {
            labelInfo.setText("Поле не должно быть пустым!");
            labelInfo.setForeground(COLOR_BORDER_WRONG);
            infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
            return;
        }
        else
            labelInfo.setText("ФИО '" + textForNames.getText() + "' сохранено");
        placeForConfirmation.setVisible(true);
        writeDate(save);
        infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
        textForNames.setText("");


        sortBoxNames.removeAllItems();
        boxNames.removeAllItems();

        for(String counter : listForNames) {
            boxNames.addItem(counter);
            sortBoxNames.addItem(counter);
        }
    }
}
class SaveSubjects extends Main.OpenFormSubject implements ActionListener { /// save date for objects
    public void actionPerformed(ActionEvent event) {
        save = textForSubjects.getText();
        labelInfoFrame.setForeground(COLOR_BORDER_SUCCESS);
        if(save.isEmpty()) {
            labelInfoFrame.setText("Поле не должно быть пустым!");
            labelInfoFrame.setForeground(COLOR_BORDER_WRONG);
            infoAboutEvent.setIcon(new ImageIcon("src/noConfirmed.png"));
            return;
        }
        else
            labelInfoFrame.setText("Дисциплина '" + textForSubjects.getText() + "' сохранена");
        placeForConfirmation.setVisible(true);
        writeDate(save);
        infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
        textForSubjects.setText("");

        boxSubjects.removeAllItems();
        for(String counter : listForSubjects) {
            boxSubjects.addItem(counter);
        }
    }
}

class DeleteAllDates extends Main.TableDate implements ActionListener {
    public void actionPerformed(ActionEvent event) {

        String[] listFiles = {"Repository.txt",
                "DoneSchedule.txt",
                "NamesList.txt",
                "GroupsList.txt",
                "SubjectsList.txt",
                "Check.txt"};

        Object[] options = {"Да",
                "Нет"};

        int userChoice = JOptionPane.showOptionDialog(frameOfTable,
                "Вы действительно хотите удалить все данные?",
                "Удаление данных",
                JOptionPane.YES_NO_CANCEL_OPTION,
                JOptionPane.QUESTION_MESSAGE,
                null,
                options,
                options[1]);

        if(userChoice == 0) {

            try {
                for (String choiceFile : listFiles) {
                    FileWriter write = new FileWriter(choiceFile);
                    write.write("");
                    write.close();
                }

            } catch (IOException e) {
                JOptionPane.showMessageDialog(null, "Удаление не завершено по неизвестной причине");
            }
            JOptionPane.showMessageDialog(null, "Удаление завершено!");
            infoAboutEvent.setIcon(new ImageIcon("src/confirmed.png"));
        }
        else
            JOptionPane.showMessageDialog(null, "Удаление отменено!");
    }
}
